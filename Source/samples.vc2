*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="samples.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS colorselector AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: ccolorsource		&& The source of the color
		*p: _memberdata
	*</DefinedPropArrayMethod>

	ccolorsource = 		&& The source of the color
	FillStyle = 0
	Height = 16
	Name = "colorselector"
	ToolTipText = "Click to select the desired color"
	Width = 16
	_memberdata = <VFPData>
		<memberdata name="ccolorsource" display="cColorSource"/>
		</VFPData>
	
	PROCEDURE Click
		local lnColor
		lnColor = getcolor(This.FillColor)
		if lnColor >= 0
			store lnColor to (This.cColorSource), This.FillColor
			Thisform.DrawGauge()
		endif lnColor >= 0
		
	ENDPROC

	PROCEDURE Refresh
		This.FillColor = evaluate(This.cColorSource)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fontselector AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="txtFont" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFont" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: setfont		&& Sets the font information
		*m: updatefont		&& Updates the font information
		*p: cfontname		&& The font name
		*p: lfontbold		&& .T. if the font is bold
		*p: lfontitalic		&& .T. if the font is italic
		*p: nfontcharset		&& The nFontCharSet to use
		*p: nfontsize		&& The font size
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	cfontname = 		&& The font name
	Height = 23
	lfontbold = .F.		&& .T. if the font is bold
	lfontitalic = .F.		&& .T. if the font is italic
	Name = "fontselector"
	nfontcharset = 1		&& The nFontCharSet to use
	nfontsize = 0		&& The font size
	Width = 288
	_memberdata = <VFPData>
		<memberdata name="cfontname" display="cFontName"/>
		<memberdata name="lfontbold" display="lFontBold"/>
		<memberdata name="lfontitalic" display="lFontItalic"/>
		<memberdata name="nfontcharset" display="nFontCharSet"/>
		<memberdata name="nfontsize" display="nFontSize"/>
		<memberdata name="setfont" display="SetFont"/>
		<memberdata name="updatefont" display="UpdateFont"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'cmdFont' AS commandbutton WITH ;
		Caption = "...", ;
		FontName = "Tahoma", ;
		Height = 23, ;
		Left = 265, ;
		Name = "cmdFont", ;
		Width = 23
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'txtFont' AS textbox WITH ;
		FontName = "Tahoma", ;
		Height = 23, ;
		Name = "txtFont", ;
		ReadOnly = .T., ;
		Width = 265
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE setfont		&& Sets the font information
		* Set the font information.
		
		lparameters tcFontName, ;
			tnFontSize, ;
			tlFontBold, ;
			tlFontItalic, ;
			tnFontCharSet
		local laFont[1], ;
			llFontOK, ;
			lnFontCharSet
		if vartype(tnFontCharSet) <> 'N' or tnFontCharSet < 0
			llFontOK = afont(laFont, tcFontName, tnFontSize)
		else
			llFontOK = afont(laFont, tcFontName, tnFontCharSet, 1)
		endif vartype(tnFontCharSet) <> 'N' ...
		with This
			.cFontName    = tcFontName
			.nFontSize    = tnFontSize
			.lFontBold    = tlFontBold
			.lFontItalic  = tlFontItalic
			.nFontCharSet = iif(vartype(tnFontCharSet) = 'N', tnFontCharSet, ;
				.nFontCharSet)
		endwith
		This.UpdateFont()
		
	ENDPROC

	PROCEDURE updatefont		&& Updates the font information
		* Update the textbox with the current font information.
		
		local lcFontCharSet
		with This
			do case
				case .nFontCharSet = 2
					lcFontCharSet = 'Symbol'
				case .nFontCharSet = 128
					lcFontCharSet = 'Japanese'
				case .nFontCharSet = 161
					lcFontCharSet = 'Greek'
				case .nFontCharSet = 162
					lcFontCharSet = 'Turkish'
				case .nFontCharSet = 163
					lcFontCharSet = 'Vietnamese'
				case .nFontCharSet = 177
					lcFontCharSet = 'Hebrew'
				case .nFontCharSet = 178
					lcFontCharSet = 'Arabic'
				case .nFontCharSet = 186
					lcFontCharSet = 'Baltic'
				case .nFontCharSet = 204
					lcFontCharSet = 'Cyrillic'
				case .nFontCharSet = 238
					lcFontCharSet = 'Central European'
				otherwise
					lcFontCharSet = ''
			endcase
			.txtFont.Value = .cFontName + ' ' + transform(.nFontSize) + ' pt' + ;
				iif(.lFontBold, ' bold', '') + iif(.lFontItalic, ' italic', '') + ;
				iif(empty(lcFontCharSet), '', ', ' + lcFontCharSet)
		endwith
		
	ENDPROC

	PROCEDURE cmdFont.Click
		* Display the selected font information in the label.
		
		local lcFontName, ;
			lnFontSize, ;
			lcStyle, ;
			lnFontCharSet, ;
			lcFont, ;
			lnPos1, ;
			lnPos2, ;
			lnPos3, ;
			llReturn
		with This.Parent
			lcFontName    = evl(.cFontName, 'Arial')
			lnFontSize    = evl(.nFontSize, 10)
			lcStyle       = iif(.lFontBold, 'B', '') + iif(.lFontItalic, 'I', '')
			lnFontCharSet = iif(.nFontCharSet < 0, 1, .nFontCharSet)
			try
				lcFont  = getfont(lcFontName, lnFontSize, lcStyle, lnFontCharSet)
			catch
			endtry
			if not empty(lcFont)
				lnPos1        = at(',', lcFont)
				lnPos2        = at(',', lcFont, 2)
				lnPos3        = at(',', lcFont, 3)
				.cFontName    = left(lcFont, lnPos1 - 1)
				.nFontSize    = val(substr(lcFont, lnPos1 + 1, lnPos2 - lnPos1 - 1))
				lcStyle       = substr(lcFont, lnPos2 + 1, lnPos3 - lnPos2 - 1)
				.lFontBold    = 'B' $ lcStyle
				.lFontItalic  = 'I' $ lcStyle
				.nFontCharSet = val(substr(lcFont, lnPos3 + 1))
				llReturn      = .T.
			endif not empty(lcFont)
		endwith
		This.Parent.UpdateFont()
		return llReturn
		
	ENDPROC

	PROCEDURE txtFont.When
		* Prevent the control from getting focus.
		
		return .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gaugespinner AS spinner 
 	*< CLASSDATA: Baseclass="spinner" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: drawgauge		&& Draws the gauge if the value changed
		*p: nsavedvalue		&& The orginal value
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	FontName = "Tahoma"
	Height = 24
	Name = "gaugespinner"
	nsavedvalue = -1		&& The orginal value
	SelectOnEntry = .T.
	Width = 121
	_memberdata = <VFPData>
		<memberdata name="drawgauge" display="DrawGauge"/>
		<memberdata name="nsavedvalue" display="nSavedValue"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE DownClick
		store This.Value to (This.ControlSource)
		This.DrawGauge()
		
	ENDPROC

	PROCEDURE drawgauge		&& Draws the gauge if the value changed
		if This.Value <> This.nSavedValue
			Thisform.DrawGauge()
		endif This.Value <> This.nSavedValue
		This.nSavedValue = This.Value
		
	ENDPROC

	PROCEDURE GotFocus
		This.nSavedValue = This.Value
		
	ENDPROC

	PROCEDURE LostFocus
		This.DrawGauge()
		
	ENDPROC

	PROCEDURE UpClick
		store This.Value to (This.ControlSource)
		This.DrawGauge()
		
	ENDPROC

ENDDEFINE
